window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "exdpn", "modulename": "exdpn", "type": "module", "doc": "<p>exdpn (e<strong>x</strong>plainable <strong>d</strong>ata <strong>P</strong>etri <strong>n</strong>ets) is a tool to mine and evaluate explainable data Petri nets using different classification techniques.</p>\n\n<hr />\n\n<h2 id=\"getting-started\">Getting Started</h2>\n\n<p>Installing exdpn is possible via pip:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>python -m pip install exdpn \n</code></pre></div>\n\n<p>Now you can mine your first explainable data Petri net given an event log in XES format:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">import_log</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.data_petri_net</span> <span class=\"kn\">import</span> <span class=\"n\">Data_Petri_Net</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">event_log</span> <span class=\"o\">=</span> <span class=\"n\">import_log</span><span class=\"p\">(</span><span class=\"s1\">&#39;&lt;path_to_event_log.xes&gt;&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">dpn</span> <span class=\"o\">=</span> <span class=\"n\">Data_Petri_Net</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">,</span> <span class=\"n\">event_level_attributes</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;event_level_attribute&#39;</span><span class=\"p\">])</span>\n</code></pre></div>\n\n<p>This will mine a data Petri net for your event log, considering only \"event_level_attribute\" as a possible attribute for classification. \nThe <code>exdpn.data_petri_net.data_petri_net.Data_Petri_Net</code> class already takes care of the workflow to create a data Petri net. In cases where fine-grained \ncontrol of the data Petri net creation is needed or only certain functionallity of this package is needed, one can simply call all the needed functions and methods directly. </p>\n\n<p>Let's say we are only interested in extracting the guard dataset at one specific decision point in the Petri net.\nWe start off by importing the event log from memory and creating a standard Petri net:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">import_log</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.petri_net</span> <span class=\"kn\">import</span> <span class=\"n\">get_petri_net</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">event_log</span> <span class=\"o\">=</span> <span class=\"n\">import_log</span><span class=\"p\">(</span><span class=\"s1\">&#39;&lt;path_to_event_log.xes&gt;&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pn</span><span class=\"p\">,</span> <span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">get_petri_net</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>We then extract all the decision points and specify our place of interest using the <code>exdpn.decisionpoints</code> module:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.decisionpoints</span> <span class=\"kn\">import</span> <span class=\"n\">find_decision_points</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">dp_dict</span> <span class=\"o\">=</span> <span class=\"n\">find_decision_points</span><span class=\"p\">(</span><span class=\"n\">pn</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">decision_point</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">dp_dict</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n</code></pre></div>\n\n<p>To extract a guard dataset for the specific place <code>decision_point</code>, we call the following data extraction function from <code>exdpn.guard_datasets</code>:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.guard_datasets</span> <span class=\"kn\">import</span> <span class=\"n\">extract_all_datasets</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">dataset</span> <span class=\"o\">=</span> <span class=\"n\">extract_all_datasets</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">,</span> <span class=\"n\">net</span><span class=\"p\">,</span> <span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">fm</span><span class=\"p\">,</span> <span class=\"n\">event_level_attributes</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;event_level_attribute&#39;</span><span class=\"p\">],</span> <span class=\"n\">places</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">decision_point</span><span class=\"p\">])</span>\n</code></pre></div>\n\n<p>Further examples can be seen in the API documentation. The sometimes referenced XES file <code>p2p_base.xes</code> can be found on Github.</p>\n\n<hr />\n\n<h2 id=\"documentation\">Documentation</h2>\n\n<p>This package provides an <a href=\"https://aarkue.github.io/eXdpn\">API documentation</a> online.</p>\n\n<h2 id=\"source-code-and-ui-application\">Source Code and UI-application</h2>\n\n<p>The source code of this package is available on Github (<a href=\"https://github.com/aarkue/eXdpn\">aarkue/eXdpn</a>).\nFurthermore, the Github also includes a graphical user interface in the form of a Python-webserver and a Docker container to easily start the web-UI locally. </p>\n\n<hr />\n"}, {"fullname": "exdpn.data_petri_net", "modulename": "exdpn.data_petri_net", "type": "module", "doc": "<p>This module provides the core functionality of the package and contains everything needed to set up the data petri net.</p>\n"}, {"fullname": "exdpn.data_petri_net.data_petri_net", "modulename": "exdpn.data_petri_net.data_petri_net", "type": "module", "doc": "<p>This module provides the core functionality of the package and contains everything needed to set up the data petri net.</p>\n"}, {"fullname": "exdpn.data_petri_net.data_petri_net.Data_Petri_Net", "modulename": "exdpn.data_petri_net.data_petri_net", "qualname": "Data_Petri_Net", "type": "class", "doc": "<p></p>\n"}, {"fullname": "exdpn.data_petri_net.data_petri_net.Data_Petri_Net.__init__", "modulename": "exdpn.data_petri_net.data_petri_net", "qualname": "Data_Petri_Net.__init__", "type": "function", "doc": "<p>Initializes a data Petri net based on the event log provided.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>event_log (EventLog):</strong>  Event log to be used as a basis for the data Petri net</li>\n<li><strong>petri_net (PetriNet):</strong>  Petri net corresponding to the event log. Does not have to be supplied</li>\n<li><strong>initial_marking (Marking):</strong>  Initial marking of the Petri net corresponding to the event log. Does not have to be supplied</li>\n<li><strong>final_marking (Marking):</strong>  Final marking of the Petri net corresponding to the event log. Does not have to be supplied</li>\n<li><strong>miner_type (str):</strong>  Spezifies type of mining algorithm, either inductive miner (\"IM\") or alpha miner (\"AM\", default)</li>\n<li><strong>case_level_attributes (List[str]):</strong>  Attribute list on the level of cases to be considered for each instance in the datasets</li>\n<li><strong>event_level_attributes (List[str]):</strong>  Attribute list on the level of events to be considered for each instance in the datasets</li>\n<li><strong>tail_length (int):</strong>  Number of events lookback to extract executed activity. Defaults to 3.</li>\n<li><strong>activityName_key (str):</strong>  Event level attribute name corresponding to the name of an event. Defaults to \"concept:name\"</li>\n<li><strong>ml_list (List[ML_Technique]):</strong>  List of all machine learning techniques that should be evaluated, default is all             implemented techniques</li>\n<li><strong>hyperparameters (Dict[ML_Technique, Dict[str, Any]]):</strong>  Hyperparameter that should be used for the machine learning techniques,             if not specified default parameters are used</li>\n<li><strong>guard_threshold (float):</strong>  Threshold (between 0 and 1) that determines if guard is added to the data petri net or not, if the guard performance             is smaller than the threshold the guard is not added. Default is 0 (no threshold) </li>\n<li><strong>verbose (bool):</strong>  Specifies if the execution of all methods should print status-esque messages or not</li>\n</ul>\n", "signature": "(\n    self,\n    event_log: pm4py.objects.log.obj.EventLog,\n    petri_net: pm4py.objects.petri_net.obj.PetriNet = None,\n    initial_marking: pm4py.objects.petri_net.obj.Marking = None,\n    final_marking: pm4py.objects.petri_net.obj.Marking = None,\n    miner_type: str = 'AM',\n    case_level_attributes: List[str] = [],\n    event_level_attributes: List[str] = [],\n    tail_length: int = 3,\n    activityName_key: str = 'concept:name',\n    ml_list: List[exdpn.guards.ml_technique.ML_Technique] = [<ML_Technique.DT: <class 'exdpn.guards.decision_tree_guard.Decision_Tree_Guard'>>, <ML_Technique.LR: <class 'exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard'>>, <ML_Technique.SVM: <class 'exdpn.guards.svm_guard.SVM_Guard'>>, <ML_Technique.NN: <class 'exdpn.guards.neural_network_guard.Neural_Network_Guard'>>],\n    hyperparameters: Dict[exdpn.guards.ml_technique.ML_Technique, Dict[str, Any]] = {<ML_Technique.NN: <class 'exdpn.guards.neural_network_guard.Neural_Network_Guard'>>: {'hidden_layer_sizes': (10, 10)}, <ML_Technique.DT: <class 'exdpn.guards.decision_tree_guard.Decision_Tree_Guard'>>: {'min_samples_split': 0.1, 'min_samples_leaf': 0.1, 'ccp_alpha': 0.2}, <ML_Technique.LR: <class 'exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard'>>: {'C': 0.5}, <ML_Technique.SVM: <class 'exdpn.guards.svm_guard.SVM_Guard'>>: {'C': 0.5}},\n    guard_threshold: float = 0.0,\n    verbose: bool = True\n)", "funcdef": "def"}, {"fullname": "exdpn.data_petri_net.data_petri_net.Data_Petri_Net.print_if_verbose", "modulename": "exdpn.data_petri_net.data_petri_net", "qualname": "Data_Petri_Net.print_if_verbose", "type": "function", "doc": "<p>Internal method used as a shortcut for printing messages only if self.verbose is set to True.</p>\n", "signature": "(self, string: str, end: str = '\\n')", "funcdef": "def"}, {"fullname": "exdpn.data_petri_net.data_petri_net.Data_Petri_Net.get_best", "modulename": "exdpn.data_petri_net.data_petri_net", "qualname": "Data_Petri_Net.get_best", "type": "function", "doc": "<p>Returns the best guard for each decision point in the data Petri net.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict[PetriNet.Place, Guard]: The best performing guard for each decision point with respect to the F1-score</p>\n</blockquote>\n", "signature": "(\n    self\n) -> Dict[pm4py.objects.petri_net.obj.PetriNet.Place, exdpn.guards.guard.Guard]", "funcdef": "def"}, {"fullname": "exdpn.data_petri_net.data_petri_net.Data_Petri_Net.get_guard_at_place", "modulename": "exdpn.data_petri_net.data_petri_net", "qualname": "Data_Petri_Net.get_guard_at_place", "type": "function", "doc": "<p>Returns the best guard for given decision point.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>place (PetriNet.Place):</strong>  The decision point to looked up</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Guard: The best guard for given decision point</p>\n</blockquote>\n", "signature": "(\n    self,\n    place: pm4py.objects.petri_net.obj.PetriNet.Place\n) -> exdpn.guards.guard.Guard", "funcdef": "def"}, {"fullname": "exdpn.data_petri_net.data_petri_net.Data_Petri_Net.get_mean_guard_conformance", "modulename": "exdpn.data_petri_net.data_petri_net", "qualname": "Data_Petri_Net.get_mean_guard_conformance", "type": "function", "doc": "<p>Returns the mean conformance for the given event log, i.e., the percentage of traces (which fit on the mined model) where all guards were respected.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>test_event_log (EventLog):</strong>  The event log used to test the performance of the data Perti net</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float: Fraction of traces that respected all decision point guards passed during token based replay.                 Respecting a decision point guard means moving to the transition predicted by the guard at the corresponding place</p>\n</blockquote>\n", "signature": "(self, test_event_log: pm4py.objects.log.obj.EventLog) -> float", "funcdef": "def"}, {"fullname": "exdpn.data_preprocessing", "modulename": "exdpn.data_preprocessing", "type": "module", "doc": "<p>This module provides basic preprocessing functionalities for the extracted guard datasets before the guard modeling. </p>\n"}, {"fullname": "exdpn.data_preprocessing.data_preprocessing", "modulename": "exdpn.data_preprocessing.data_preprocessing", "type": "module", "doc": "<p>This module provides basic preprocessing functionalities for the extracted guard datasets before the guard modeling. </p>\n"}, {"fullname": "exdpn.data_preprocessing.data_preprocessing.data_preprocessing_evaluation", "modulename": "exdpn.data_preprocessing.data_preprocessing", "qualname": "data_preprocessing_evaluation", "type": "function", "doc": "<p>Data preprocessing for dataframes before they are used for the machine learning model selection. This does some     basic preprocessing, such as converting all columns to the correct data type, droping of columns with only NaNs and     defining feature variables and target variables. Furthermore, the data is split into a train and test data sets     and each numeric feature is scaled with a MinMaxScaler to [0, 1]    into training and test sets.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>dataframe (DataFrame):</strong>  Dataframe to be transformed for evaluation of the best model</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>X_train, X_test, y_train, y_test (DataFrame): Preprocessed and splitted data</p>\n</blockquote>\n", "signature": "(\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame, pandas.core.series.Series, pandas.core.series.Series]", "funcdef": "def"}, {"fullname": "exdpn.data_preprocessing.data_preprocessing.basic_data_preprocessing", "modulename": "exdpn.data_preprocessing.data_preprocessing", "qualname": "basic_data_preprocessing", "type": "function", "doc": "<p>Basic preprocessing before dataframes, i.e., dropping of columns     with only NaNs and defining feature variables and target variables</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>dataframe (DataFrame):</strong>  Dataframe to be transformed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>df_X (DataFrame): Preprocessed dataframe of feature variables\n  df_y (DataFrame): Preprocessed dataframe of target variable</p>\n</blockquote>\n", "signature": "(\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "exdpn.data_preprocessing.data_preprocessing.fit_scaling", "modulename": "exdpn.data_preprocessing.data_preprocessing", "qualname": "fit_scaling", "type": "function", "doc": "<p>Fits a MinMaxScaler on the data and returns a scaler for a scaling t o [0, 1] and the scalable columns </p>\n\n<p>Args: \n    X (DataFrame): Dataframe with data to scale</p>\n\n<p>Returns: \n    scaler (MinMaxScaler): MinMaxScaler fitted on data set, scales to [0, 1]\n    scalable_columns (pandas.core.indexes.base.Index): List of columns names of all columns that can be scaled</p>\n", "signature": "(\n    X: pandas.core.frame.DataFrame\n) -> Tuple[sklearn.preprocessing._data.MinMaxScaler, List[str]]", "funcdef": "def"}, {"fullname": "exdpn.data_preprocessing.data_preprocessing.apply_scaling", "modulename": "exdpn.data_preprocessing.data_preprocessing", "qualname": "apply_scaling", "type": "function", "doc": "<p>Performs min-max scaling to [0, 1] on data with a fitted scaler on all scalable columns and returns scaled data</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Dataframe with data to scale</li>\n<li><strong>scaler (MinMaxScaler):</strong>  MinMaxScaler fitted on data set, scales to [0, 1]</li>\n<li><strong>scalable_columns (pandas.core.indexes.base.Index):</strong>  List of columns names of all columns that can be scaled</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>X_scaled (DataFrame): Scaled data, where each feature is scaled to [0, 1]</p>\n</blockquote>\n", "signature": "(\n    X: pandas.core.frame.DataFrame,\n    scaler: sklearn.preprocessing._data.MinMaxScaler,\n    scalable_columns: List[str]\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "exdpn.data_preprocessing.data_preprocessing.fit_ohe", "modulename": "exdpn.data_preprocessing.data_preprocessing", "qualname": "fit_ohe", "type": "function", "doc": "<p>Fits anOneHotEncoder on all categorical features in the data set</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Dataframe with data to encode</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>OneHotEncoder (OneHotEncoder): Fitted Encoder, used to encode categorical data\n  ohe_column_names (List[str]): List of column names of One Hot Encoded dataframe</p>\n</blockquote>\n", "signature": "(\n    X: pandas.core.frame.DataFrame\n) -> Tuple[sklearn.preprocessing._encoders.OneHotEncoder, List[str]]", "funcdef": "def"}, {"fullname": "exdpn.data_preprocessing.data_preprocessing.apply_ohe", "modulename": "exdpn.data_preprocessing.data_preprocessing", "qualname": "apply_ohe", "type": "function", "doc": "<p>Performs One Hot Encoding on all categorical features in the data set. This is necessary for machine learning     techniques that cannot handle categorical data, such as Decision Trees, SVMs and Neural Networks</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Dataframe with data to encode</li>\n<li><strong>OneHotEncoder (OneHotEncoder):</strong>  Fitted Encoder, used to encode categorical data</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>X_encoded (DataFrame): Encoded data, if dataframe does not contain categorical data, the original         dataframe is returned</p>\n</blockquote>\n", "signature": "(\n    X: pandas.core.frame.DataFrame,\n    ohe: sklearn.preprocessing._encoders.OneHotEncoder\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "exdpn.decisionpoints", "modulename": "exdpn.decisionpoints", "type": "module", "doc": "<p>This is a module providing the functionallity to get all decision points from a Petri net. </p>\n\n<hr />\n\n<h2 id=\"decision-points\">Decision Points</h2>\n\n<p>A decision point is a place in the Petri net with at least two outgoing transitions (i.e., arcs to transitions).</p>\n\n<hr />\n"}, {"fullname": "exdpn.decisionpoints.find", "modulename": "exdpn.decisionpoints.find", "type": "module", "doc": "<p>This is a module providing the functionallity to get all decision points from a Petri net. </p>\n\n<hr />\n\n<h2 id=\"decision-points\">Decision Points</h2>\n\n<p>A decision point is a place in the Petri net with at least two outgoing transitions (i.e., arcs to transitions).</p>\n\n<hr />\n"}, {"fullname": "exdpn.decisionpoints.find.find_decision_points", "modulename": "exdpn.decisionpoints.find", "qualname": "find_decision_points", "type": "function", "doc": "<p>Finds decision points in a Petri net. </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>net (PetriNet):</strong>  The pm4py Petri net in which to find decision points.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict[PetriNet.Place, Set[PetriNet.Transition]]: A dictionary mapping places to the possible outgoing transitions.</p>\n</blockquote>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">import_log</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.petri_net</span> <span class=\"kn\">import</span> <span class=\"n\">get_petri_net</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.decisionpoints</span> <span class=\"kn\">import</span> <span class=\"n\">find_decision_points</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">event_log</span> <span class=\"o\">=</span> <span class=\"n\">import_log</span><span class=\"p\">(</span><span class=\"s1\">&#39;p2p_base.xes&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pn</span><span class=\"p\">,</span> <span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">get_petri_net</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">dp_dict</span> <span class=\"o\">=</span> <span class=\"n\">find_decision_points</span><span class=\"p\">(</span><span class=\"n\">pn</span><span class=\"p\">)</span>\n</code></pre></div>\n</blockquote>\n", "signature": "(\n    net: pm4py.objects.petri_net.obj.PetriNet\n) -> Dict[pm4py.objects.petri_net.obj.PetriNet.Place, Set[pm4py.objects.petri_net.obj.PetriNet.Transition]]", "funcdef": "def"}, {"fullname": "exdpn.guard_datasets", "modulename": "exdpn.guard_datasets", "type": "module", "doc": "<p>This module provides the function to extract a dataset for each decision point in a Petri net given an event log and attributes to record.</p>\n\n<hr />\n\n<h2 id=\"guard-datasets\">Guard-Datasets</h2>\n\n<p>Each row/instance in a guard-dataset corresponds to a trace visiting the corresponding decision point (see module <code>exdpn.decisionpoints</code>) during token-based replay. This could potentially happen several times. For each such visit, the algorithm records the specified case-level attributes, event-level attributes (for the previous event in the case), and a tail of preceding events. These records make up the columns of the guard-dataset. In order to eventually do perdictions with the data, the following event (i.e., transition) is recorded in the \"target\" column.</p>\n\n<hr />\n"}, {"fullname": "exdpn.guard_datasets.data_extraction", "modulename": "exdpn.guard_datasets.data_extraction", "type": "module", "doc": "<p>This module provides the function to extract a dataset for each decision point in a Petri net given an event log and attributes to record.</p>\n\n<hr />\n\n<h2 id=\"guard-datasets\">Guard-Datasets</h2>\n\n<p>Each row/instance in a guard-dataset corresponds to a trace visiting the corresponding decision point (see module <code>exdpn.decisionpoints</code>) during token-based replay. This could potentially happen several times. For each such visit, the algorithm records the specified case-level attributes, event-level attributes (for the previous event in the case), and a tail of preceding events. These records make up the columns of the guard-dataset. In order to eventually do perdictions with the data, the following event (i.e., transition) is recorded in the \"target\" column.</p>\n\n<hr />\n"}, {"fullname": "exdpn.guard_datasets.data_extraction.extract_all_datasets", "modulename": "exdpn.guard_datasets.data_extraction", "qualname": "extract_all_datasets", "type": "function", "doc": "<p>Extracts a dataset for each decision point using token-based replay. For each instance of this decision found in the log, the following data is extracted:</p>\n\n<ol>\n<li>The specified case-level attributes of the case</li>\n<li>The specified event-level attributes of the last event of the case before this decision is made</li>\n<li>The acitivities executed in the events contained in the <code>tail_length</code> events before the decision</li>\n<li>The transition which is chosen (the <em>target</em> class)</li>\n</ol>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>log (EventLog):</strong>  The event log to extract the data from.</li>\n<li><strong>net (PetriNet, optional):</strong>  The Petri net on which the token-based replay will be performed (and on which the decision points are identified,         not optional if places are not provided).</li>\n<li><strong>initial_marking (Marking, optional):</strong>  The initial marking of the Petri net.</li>\n<li><strong>final_marking (Marking, optional):</strong>  The final marking of the Petri net.</li>\n<li><strong>case_level_attributes (List[str], optional):</strong>  The list of attributes to be extracted on a case-level. Defaults to empty list.</li>\n<li><strong>event_level_attributes (List[str], optional):</strong>  The list of attributes to be extracted on an event-level. Defaults to empty list.</li>\n<li><strong>tail_length (int, optional):</strong>  The number of preceding events to record. Defaults to 3.</li>\n<li><strong>activityName_key (str, optional):</strong>  The key of the activity name in the event log. Defaults to <code>pm4py.util.xes_constants.DEFAULT_NAME_KEY</code> (\"concept:name\").</li>\n<li><strong>places (List[Place], optional):</strong>  The list of places to extract datasets for. If not present, all decision points are regarded.</li>\n<li><strong>padding (Any, optional):</strong>  The padding to be used when the tail goes over beginning of the case. Defaults to \"#\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict[Place, DataFrame]: The dictionary mapping places in the Petri net to their corresponding dataset.</p>\n</blockquote>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">import_log</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">extend_event_log_with_preceding_event_delay</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.petri_net</span> <span class=\"kn\">import</span> <span class=\"n\">get_petri_net</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.guard_datasets</span> <span class=\"kn\">import</span> <span class=\"n\">extract_all_datasets</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">event_log</span> <span class=\"o\">=</span> <span class=\"n\">import_log</span><span class=\"p\">(</span><span class=\"s1\">&#39;p2p_base.xes&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">extend_event_log_with_preceding_event_delay</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">,</span> <span class=\"s1\">&#39;delay&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pn</span><span class=\"p\">,</span> <span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">get_petri_net</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">dp_dataset_map</span> <span class=\"o\">=</span> <span class=\"n\">extract_all_datasets</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">,</span> <span class=\"n\">pn</span><span class=\"p\">,</span> <span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">fm</span><span class=\"p\">,</span> <span class=\"n\">event_level_attributes</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;delay&#39;</span><span class=\"p\">])</span>\n</code></pre></div>\n</blockquote>\n", "signature": "(\n    log: pm4py.objects.log.obj.EventLog,\n    net: pm4py.objects.petri_net.obj.PetriNet,\n    initial_marking: pm4py.objects.petri_net.obj.Marking = None,\n    final_marking: pm4py.objects.petri_net.obj.Marking = None,\n    case_level_attributes: List[str] = [],\n    event_level_attributes: List[str] = [],\n    tail_length: int = 3,\n    activityName_key: str = 'concept:name',\n    places: List[pm4py.objects.petri_net.obj.PetriNet.Place] = None,\n    padding: Any = '#'\n) -> Dict[pm4py.objects.petri_net.obj.PetriNet.Place, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "exdpn.guard_datasets.data_extraction.extract_dataset_for_place", "modulename": "exdpn.guard_datasets.data_extraction", "qualname": "extract_dataset_for_place", "type": "function", "doc": "<p>Extracts the dataset for a single place using token-based replay. For each instance of this decision found in the log, the following data is extracted:</p>\n\n<ol>\n<li>The specified case-level attributes of the case</li>\n<li>The specified event-level attributes of the last event of the case before this decision is made</li>\n<li>The acitivities executed in the events contained in the <code>tail_length</code> events before the decision</li>\n<li>The transition which is chosen (the <em>target</em> class)</li>\n</ol>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>place (PetriNet.Place):</strong>  The place for which to extract the data.</li>\n<li><strong>target_transitions (Dict[PetriNet.Place, PetriNet.Transition]):</strong>  The transitions which have an input arc from this place.</li>\n<li><strong>log (EventLog):</strong>  The Event Log from which to extract the data.</li>\n<li><strong>replay (List[Dict[str, Any]] | Tuple[PetriNet, Marking, Marking]):</strong>  Either the token-based replay computed by PM4Py, or the net which to use to compute the replay.</li>\n<li><strong>case_level_attributes (List[str], optional):</strong>  The list of attributes to be extracted on a case-level. Defaults to empty list.</li>\n<li><strong>event_level_attributes (List[str], optional):</strong>  The list of attributes to be extracted on an event-level. Defaults to empty list.</li>\n<li><strong>tail_length (int, optional):</strong>  The number of preceding events to record. Defaults to 3.</li>\n<li><strong>activityName_key (str, optional):</strong>  The key of the activity name in the event log. Defaults to <code>pm4py.util.xes_constants.DEFAULT_NAME_KEY</code> (\"concept:name\").</li>\n<li><strong>padding (Any, optional):</strong>  The padding to be used when the tail goes over beginning of the case. Defaults to \"#\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>DataFrame: The guard-dataset extracted for the decision point at <code>place</code>.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>Exception:</strong>  If the default case ID key defined by the XES standard (\"concept:name\") is not among the case-level attributes.</li>\n</ul>\n", "signature": "(\n    place: pm4py.objects.petri_net.obj.PetriNet.Place,\n    target_transitions: Dict[pm4py.objects.petri_net.obj.PetriNet.Place, pm4py.objects.petri_net.obj.PetriNet.Transition],\n    log: pm4py.objects.log.obj.EventLog,\n    replay: Union[List[Dict[str, Any]], Tuple[pm4py.objects.petri_net.obj.PetriNet, pm4py.objects.petri_net.obj.Marking, pm4py.objects.petri_net.obj.Marking]],\n    case_level_attributes: List[str] = [],\n    event_level_attributes: List[str] = [],\n    tail_length: int = 3,\n    activityName_key: str = 'concept:name',\n    padding: Any = '#'\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "exdpn.guards", "modulename": "exdpn.guards", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.decision_tree_guard", "modulename": "exdpn.guards.decision_tree_guard", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.decision_tree_guard.Decision_Tree_Guard", "modulename": "exdpn.guards.decision_tree_guard", "qualname": "Decision_Tree_Guard", "type": "class", "doc": "<p></p>\n", "bases": "exdpn.guards.guard.Guard"}, {"fullname": "exdpn.guards.decision_tree_guard.Decision_Tree_Guard.__init__", "modulename": "exdpn.guards.decision_tree_guard", "qualname": "Decision_Tree_Guard.__init__", "type": "function", "doc": "<p>Initializes a decision tree based guard with the provided hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hyperparameters (Dict[str, Any]):</strong>  Hyperparameters used for the classifier</li>\n</ul>\n", "signature": "(\n    self,\n    hyperparameters: Dict[str, Any] = {'min_samples_split': 0.1, 'min_samples_leaf': 0.1, 'ccp_alpha': 0.2}\n)", "funcdef": "def"}, {"fullname": "exdpn.guards.decision_tree_guard.Decision_Tree_Guard.train", "modulename": "exdpn.guards.decision_tree_guard", "qualname": "Decision_Tree_Guard.train", "type": "function", "doc": "<p>Trains the decision tree guard using the dataframe and the specified hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Feature variables of the provided dataset, used to train the classifier behind the guard </li>\n<li><strong>y (DataFrame):</strong>  Target variable of the provided dataset, is to be predicted using X</li>\n</ul>\n", "signature": "(\n    self,\n    X: pandas.core.frame.DataFrame,\n    y: pandas.core.frame.DataFrame\n) -> None", "funcdef": "def"}, {"fullname": "exdpn.guards.decision_tree_guard.Decision_Tree_Guard.predict", "modulename": "exdpn.guards.decision_tree_guard", "qualname": "Decision_Tree_Guard.predict", "type": "function", "doc": "<p>Predicts the next transition based on the input instances.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_instances (DataFrame):</strong>  Dataset of input instances used to predict the target variable, i.e., the next transition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>predicted_transitions (List[PetriNet.Transition]): Predicted transitions</p>\n</blockquote>\n", "signature": "(\n    self,\n    input_instances: pandas.core.frame.DataFrame\n) -> List[pm4py.objects.petri_net.obj.PetriNet.Transition]", "funcdef": "def"}, {"fullname": "exdpn.guards.decision_tree_guard.Decision_Tree_Guard.is_explainable", "modulename": "exdpn.guards.decision_tree_guard", "qualname": "Decision_Tree_Guard.is_explainable", "type": "function", "doc": "<p>Returns whether or not this guard is explainable.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable (bool): Whether or not the guard is explainable</p>\n</blockquote>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "exdpn.guards.decision_tree_guard.Decision_Tree_Guard.get_explainable_representation", "modulename": "exdpn.guards.decision_tree_guard", "qualname": "Decision_Tree_Guard.get_explainable_representation", "type": "function", "doc": "<p>Get an explainable representation of the decision tree guard.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable_representation (Figure): Matplotlib Figure of the trained decision tree classifier</p>\n</blockquote>\n", "signature": "(self) -> matplotlib.figure.Figure", "funcdef": "def"}, {"fullname": "exdpn.guards.guard", "modulename": "exdpn.guards.guard", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.guard.Guard", "modulename": "exdpn.guards.guard", "qualname": "Guard", "type": "class", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.guard.Guard.__init__", "modulename": "exdpn.guards.guard", "qualname": "Guard.__init__", "type": "function", "doc": "<p>Initializes a guard with the provided hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hyperparameters (Dict[str, Any]):</strong>  Hyperparameters used for the classifier</li>\n</ul>\n", "signature": "(self, hyperparameters: Dict[str, Any])", "funcdef": "def"}, {"fullname": "exdpn.guards.guard.Guard.train", "modulename": "exdpn.guards.guard", "qualname": "Guard.train", "type": "function", "doc": "<p>Shall train the concrete classifier/model behind the guard using the dataframe and the specified hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Feature variables of the provided dataset, used to train the classifier behind the guard </li>\n<li><strong>y (DataFrame):</strong>  Target variable of the provided dataset, is to be predicted using X</li>\n</ul>\n", "signature": "(\n    self,\n    X: pandas.core.frame.DataFrame,\n    y: pandas.core.frame.DataFrame\n) -> None", "funcdef": "def"}, {"fullname": "exdpn.guards.guard.Guard.predict", "modulename": "exdpn.guards.guard", "qualname": "Guard.predict", "type": "function", "doc": "<p>Shall use the classifier/model behind the guard to predict the next transition.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_instances (DataFrame):</strong>  Dataset of input instances used to predict the target variable, i.e., the next transition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>predicted_transitions (List[PetriNet.Transition]): Predicted transitions</p>\n</blockquote>\n", "signature": "(\n    self,\n    input_instances: pandas.core.frame.DataFrame\n) -> List[pm4py.objects.petri_net.obj.PetriNet.Transition]", "funcdef": "def"}, {"fullname": "exdpn.guards.guard.Guard.is_explainable", "modulename": "exdpn.guards.guard", "qualname": "Guard.is_explainable", "type": "function", "doc": "<p>Shall return whether or not the internal classifier is explainable.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable (bool): Whether or not the guard is explainable</p>\n</blockquote>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "exdpn.guards.guard.Guard.get_explainable_representation", "modulename": "exdpn.guards.guard", "qualname": "Guard.get_explainable_representation", "type": "function", "doc": "<p>Shall return an explainable representation of the guard. Shall throw an exception if the guard is not explainable.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable_representation (Figure): Explainable representation of the guard</p>\n</blockquote>\n", "signature": "(self) -> matplotlib.figure.Figure", "funcdef": "def"}, {"fullname": "exdpn.guards.guard_manager", "modulename": "exdpn.guards.guard_manager", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.guard_manager.Guard_Manager", "modulename": "exdpn.guards.guard_manager", "qualname": "Guard_Manager", "type": "class", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.guard_manager.Guard_Manager.__init__", "modulename": "exdpn.guards.guard_manager", "qualname": "Guard_Manager.__init__", "type": "function", "doc": "<p>Initializes all information needed for the calculation of the best guard for each decision point and /\nreturns a dictionary with the list of all guards for each machine learning technique.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>dataframe (DataFrame):</strong>  Dataset used to evaluate the guard  </li>\n<li><strong>ml_list (List[ML_Technique]):</strong>  List of all machine learning techniques that should be evaluated, default is all implemented </li>\n<li><strong>hyperparameters (Dict[ML_Technique, Dict[str, Any]]):</strong>  Hyperparameter that should be used for the machine learning techniques,             if not specified default parameters are used</li>\n</ul>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame,\n    ml_list: List[exdpn.guards.ml_technique.ML_Technique] = [<ML_Technique.DT: <class 'exdpn.guards.decision_tree_guard.Decision_Tree_Guard'>>, <ML_Technique.LR: <class 'exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard'>>, <ML_Technique.SVM: <class 'exdpn.guards.svm_guard.SVM_Guard'>>, <ML_Technique.NN: <class 'exdpn.guards.neural_network_guard.Neural_Network_Guard'>>],\n    hyperparameters: Dict[exdpn.guards.ml_technique.ML_Technique, Dict[str, Any]] = {<ML_Technique.NN: <class 'exdpn.guards.neural_network_guard.Neural_Network_Guard'>>: {'hidden_layer_sizes': (10, 10)}, <ML_Technique.DT: <class 'exdpn.guards.decision_tree_guard.Decision_Tree_Guard'>>: {'min_samples_split': 0.1, 'min_samples_leaf': 0.1, 'ccp_alpha': 0.2}, <ML_Technique.LR: <class 'exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard'>>: {'C': 0.5}, <ML_Technique.SVM: <class 'exdpn.guards.svm_guard.SVM_Guard'>>: {'C': 0.5}}\n)", "funcdef": "def"}, {"fullname": "exdpn.guards.guard_manager.Guard_Manager.train_test", "modulename": "exdpn.guards.guard_manager", "qualname": "Guard_Manager.train_test", "type": "function", "doc": "<p>Calculates for a given decision point all selected guards and returns the precision of the machine learning model,         using the specified machine learning techniques.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>guards_results (Dict[str, Any]): Returns a mapping of all selected machine learning techniques             to the achieved F1-score and two trained guard models: the \"training\" guard (position 0) and final guard (position 1)</p>\n</blockquote>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "exdpn.guards.guard_manager.Guard_Manager.get_best", "modulename": "exdpn.guards.guard_manager", "qualname": "Guard_Manager.get_best", "type": "function", "doc": "<p>Returns \"best\" guard for a decision point.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>best_guard (Tuple[str, List[Guard, Guard]]): Returns \"best\" guard for a decision point with respect to the             chosen metric (F1 score), the returned tuple contains the machine learning technique and a list with the             corresponding \"training\" guard (position 0) and final guard (position 1)</p>\n</blockquote>\n", "signature": "(self) -> Tuple[str, List[exdpn.guards.guard.Guard]]", "funcdef": "def"}, {"fullname": "exdpn.guards.guard_manager.Guard_Manager.get_comparison_plot", "modulename": "exdpn.guards.guard_manager", "qualname": "Guard_Manager.get_comparison_plot", "type": "function", "doc": "<p>Constructs a comparison bar plot of the F1 scores for all trained techniques for a place</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Figure: The bar plot figure</p>\n</blockquote>\n", "signature": "(self) -> matplotlib.figure.Figure", "funcdef": "def"}, {"fullname": "exdpn.guards.logistic_regression_guard", "modulename": "exdpn.guards.logistic_regression_guard", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard", "modulename": "exdpn.guards.logistic_regression_guard", "qualname": "Logistic_Regression_Guard", "type": "class", "doc": "<p></p>\n", "bases": "exdpn.guards.guard.Guard"}, {"fullname": "exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard.__init__", "modulename": "exdpn.guards.logistic_regression_guard", "qualname": "Logistic_Regression_Guard.__init__", "type": "function", "doc": "<p>Initializes a logistic regression based guard with the provided hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hyperparameters (Dict[str, Any]):</strong>  Hyperparameters used for the classifier</li>\n</ul>\n", "signature": "(self, hyperparameters: Dict[str, Any] = {'C': 0.5})", "funcdef": "def"}, {"fullname": "exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard.train", "modulename": "exdpn.guards.logistic_regression_guard", "qualname": "Logistic_Regression_Guard.train", "type": "function", "doc": "<p>Trains the logistic regression guard using the dataframe and the specified hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Feature variables of the provided dataset, used to train the classifier behind the guard </li>\n<li><strong>y (DataFrame):</strong>  Target variable of the provided dataset, is to be predicted using X</li>\n</ul>\n", "signature": "(\n    self,\n    X: pandas.core.frame.DataFrame,\n    y: pandas.core.frame.DataFrame\n) -> None", "funcdef": "def"}, {"fullname": "exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard.predict", "modulename": "exdpn.guards.logistic_regression_guard", "qualname": "Logistic_Regression_Guard.predict", "type": "function", "doc": "<p>Predicts the next transition based on the input instances.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_instances (DataFrame):</strong>  Dataset of input instances used to predict the target variable, i.e., the next transition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>predicted_transitions (List[PetriNet.Transition]): Predicted transitions</p>\n</blockquote>\n", "signature": "(\n    self,\n    input_instances: pandas.core.frame.DataFrame\n) -> List[pm4py.objects.petri_net.obj.PetriNet.Transition]", "funcdef": "def"}, {"fullname": "exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard.is_explainable", "modulename": "exdpn.guards.logistic_regression_guard", "qualname": "Logistic_Regression_Guard.is_explainable", "type": "function", "doc": "<p>Returns whether or not this guard is explainable.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable (bool): Whether or not the guard is explainable</p>\n</blockquote>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard.get_explainable_representation", "modulename": "exdpn.guards.logistic_regression_guard", "qualname": "Logistic_Regression_Guard.get_explainable_representation", "type": "function", "doc": "<p>Get an explainable representation of the logistic regression guard, a Matplotlib plot using SHAP.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable_representation (Figure): Matplotlib Figure of the trained logistic regression model</p>\n</blockquote>\n", "signature": "(self) -> matplotlib.figure.Figure", "funcdef": "def"}, {"fullname": "exdpn.guards.ml_technique", "modulename": "exdpn.guards.ml_technique", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.ml_technique.ML_Technique", "modulename": "exdpn.guards.ml_technique", "qualname": "ML_Technique", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.Enum"}, {"fullname": "exdpn.guards.ml_technique.ML_Technique.NN", "modulename": "exdpn.guards.ml_technique", "qualname": "ML_Technique.NN", "type": "variable", "doc": "<p></p>\n", "default_value": " = <ML_Technique.NN: <class 'exdpn.guards.neural_network_guard.Neural_Network_Guard'>>"}, {"fullname": "exdpn.guards.ml_technique.ML_Technique.DT", "modulename": "exdpn.guards.ml_technique", "qualname": "ML_Technique.DT", "type": "variable", "doc": "<p></p>\n", "default_value": " = <ML_Technique.DT: <class 'exdpn.guards.decision_tree_guard.Decision_Tree_Guard'>>"}, {"fullname": "exdpn.guards.ml_technique.ML_Technique.LR", "modulename": "exdpn.guards.ml_technique", "qualname": "ML_Technique.LR", "type": "variable", "doc": "<p></p>\n", "default_value": " = <ML_Technique.LR: <class 'exdpn.guards.logistic_regression_guard.Logistic_Regression_Guard'>>"}, {"fullname": "exdpn.guards.ml_technique.ML_Technique.SVM", "modulename": "exdpn.guards.ml_technique", "qualname": "ML_Technique.SVM", "type": "variable", "doc": "<p></p>\n", "default_value": " = <ML_Technique.SVM: <class 'exdpn.guards.svm_guard.SVM_Guard'>>"}, {"fullname": "exdpn.guards.model_builder", "modulename": "exdpn.guards.model_builder", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.model_builder.model_builder", "modulename": "exdpn.guards.model_builder", "qualname": "model_builder", "type": "function", "doc": "<p>Internal function to build a specific guard with the provided hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>model_typ (ML_Technique):</strong>  Specification of machine learning technique, use \"NN\" for neural network,         \"SVM\" for support vector machine, \"DT\" for decision tree and \"LR\" for logistic regression</li>\n<li><strong>hp (Dict[str, any]):</strong>  Hyperparameters for the machine learning model</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Guard: Machine learning guard of desired type with provided hyperparameters</p>\n</blockquote>\n", "signature": "(\n    model_type: exdpn.guards.ml_technique.ML_Technique,\n    hp: Dict[str, Any]\n) -> exdpn.guards.guard.Guard", "funcdef": "def"}, {"fullname": "exdpn.guards.neural_network_guard", "modulename": "exdpn.guards.neural_network_guard", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.neural_network_guard.Neural_Network_Guard", "modulename": "exdpn.guards.neural_network_guard", "qualname": "Neural_Network_Guard", "type": "class", "doc": "<p></p>\n", "bases": "exdpn.guards.guard.Guard"}, {"fullname": "exdpn.guards.neural_network_guard.Neural_Network_Guard.__init__", "modulename": "exdpn.guards.neural_network_guard", "qualname": "Neural_Network_Guard.__init__", "type": "function", "doc": "<p>Initializes a neural network based guard with the provided hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hyperparameters (Dict[str, Any]):</strong>  Hyperparameters used for the classifier</li>\n</ul>\n", "signature": "(\n    self,\n    hyperparameters: Dict[str, Any] = {'hidden_layer_sizes': (10, 10)}\n)", "funcdef": "def"}, {"fullname": "exdpn.guards.neural_network_guard.Neural_Network_Guard.train", "modulename": "exdpn.guards.neural_network_guard", "qualname": "Neural_Network_Guard.train", "type": "function", "doc": "<p>Trains the neural network guard using the dataframe and the specified hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Feature variables of the provided dataset, used to train the classifier behind the guard </li>\n<li><strong>y (DataFrame):</strong>  Target variable of the provided dataset, is to be predicted using X</li>\n</ul>\n", "signature": "(\n    self,\n    X: pandas.core.frame.DataFrame,\n    y: pandas.core.frame.DataFrame\n) -> None", "funcdef": "def"}, {"fullname": "exdpn.guards.neural_network_guard.Neural_Network_Guard.predict", "modulename": "exdpn.guards.neural_network_guard", "qualname": "Neural_Network_Guard.predict", "type": "function", "doc": "<p>Predicts the next transition based on the input instances.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_instances (DataFrame):</strong>  Dataset of input instances used to predict the target variable, i.e., the next transition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>predicted_transitions (List[PetriNet.Transition]): Predicted transitions</p>\n</blockquote>\n", "signature": "(\n    self,\n    input_instances: pandas.core.frame.DataFrame\n) -> List[pm4py.objects.petri_net.obj.PetriNet.Transition]", "funcdef": "def"}, {"fullname": "exdpn.guards.neural_network_guard.Neural_Network_Guard.is_explainable", "modulename": "exdpn.guards.neural_network_guard", "qualname": "Neural_Network_Guard.is_explainable", "type": "function", "doc": "<p>Returns whether or not this guard is explainable.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable (bool): Whether or not the guard is explainable</p>\n</blockquote>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "exdpn.guards.neural_network_guard.Neural_Network_Guard.get_explainable_representation", "modulename": "exdpn.guards.neural_network_guard", "qualname": "Neural_Network_Guard.get_explainable_representation", "type": "function", "doc": "<p>Get an explainable representation of the neural network guard, a Matplotlib plot using SHAP.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable_representation (Figure): Explainable representation of the guard</p>\n</blockquote>\n", "signature": "(self) -> matplotlib.figure.Figure", "funcdef": "def"}, {"fullname": "exdpn.guards.svm_guard", "modulename": "exdpn.guards.svm_guard", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.guards.svm_guard.SVM_Guard", "modulename": "exdpn.guards.svm_guard", "qualname": "SVM_Guard", "type": "class", "doc": "<p></p>\n", "bases": "exdpn.guards.guard.Guard"}, {"fullname": "exdpn.guards.svm_guard.SVM_Guard.__init__", "modulename": "exdpn.guards.svm_guard", "qualname": "SVM_Guard.__init__", "type": "function", "doc": "<p>Initializes a support vector machine based guard with the provided hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hyperparameters (Dict[str, Any]):</strong>  Hyperparameters used for the classifier</li>\n</ul>\n", "signature": "(self, hyperparameters: Dict[str, Any] = {'C': 0.5})", "funcdef": "def"}, {"fullname": "exdpn.guards.svm_guard.SVM_Guard.train", "modulename": "exdpn.guards.svm_guard", "qualname": "SVM_Guard.train", "type": "function", "doc": "<p>Trains the support vector machine guard using the dataframe and the specified hyperparameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>X (DataFrame):</strong>  Feature variables of the provided dataset, used to train the classifier behind the guard </li>\n<li><strong>y (DataFrame):</strong>  Target variable of the provided dataset, is to be predicted using X</li>\n</ul>\n", "signature": "(\n    self,\n    X: pandas.core.frame.DataFrame,\n    y: pandas.core.frame.DataFrame\n) -> None", "funcdef": "def"}, {"fullname": "exdpn.guards.svm_guard.SVM_Guard.predict", "modulename": "exdpn.guards.svm_guard", "qualname": "SVM_Guard.predict", "type": "function", "doc": "<p>Predicts the next transition based on the input instances.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_instances (DataFrame):</strong>  Input instances used to predict the next transition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>predicted_transitions (List[PetriNet.Transition]): Predicted transitions</p>\n</blockquote>\n", "signature": "(\n    self,\n    input_instances: pandas.core.frame.DataFrame\n) -> List[pm4py.objects.petri_net.obj.PetriNet.Transition]", "funcdef": "def"}, {"fullname": "exdpn.guards.svm_guard.SVM_Guard.is_explainable", "modulename": "exdpn.guards.svm_guard", "qualname": "SVM_Guard.is_explainable", "type": "function", "doc": "<p>Returns whether or not this guard is explainable.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable (bool): Wheter or not the guard is explainable</p>\n</blockquote>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "exdpn.guards.svm_guard.SVM_Guard.get_explainable_representation", "modulename": "exdpn.guards.svm_guard", "qualname": "SVM_Guard.get_explainable_representation", "type": "function", "doc": "<p>Get an explainable representation of the support vector machine guard, a Matplotlib plot using SHAP.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explainable_representation (Figure): Matplotlib Figure of the trained SVM model</p>\n</blockquote>\n", "signature": "(self) -> matplotlib.figure.Figure", "funcdef": "def"}, {"fullname": "exdpn.petri_net", "modulename": "exdpn.petri_net", "type": "module", "doc": "<p>This module contains the functionality to mine a petri net from the given event log.</p>\n"}, {"fullname": "exdpn.petri_net.get_petri_net", "modulename": "exdpn.petri_net.get_petri_net", "type": "module", "doc": "<p></p>\n"}, {"fullname": "exdpn.petri_net.get_petri_net.get_petri_net", "modulename": "exdpn.petri_net.get_petri_net", "qualname": "get_petri_net", "type": "function", "doc": "<p>Mines Petri Net based on given event log and returns found Petri Net.</p>\n\n<p>Args: \n    log (EventLog): Given event log, as EventLog\n    miner_type (str): Spezifies type of mining algorithm, either inductive miner (\"IM\") or alpha miner (\"AM\", default)\nReturns: \n    net (PetriNet): Petri Net based on input data, later used to find decision find decision points \n    initial_marking (PetriNet.Place): Initial Marking\n    final_marking (PetriNet.Place): Final Marking</p>\n", "signature": "(\n    log: pm4py.objects.log.obj.EventLog,\n    miner_type: str = 'AM'\n) -> Tuple[pm4py.objects.petri_net.obj.PetriNet, pm4py.objects.petri_net.obj.PetriNet.Place, pm4py.objects.petri_net.obj.PetriNet.Place]", "funcdef": "def"}, {"fullname": "exdpn.util", "modulename": "exdpn.util", "type": "module", "doc": "<p>This is a module providing some basic utility functions.</p>\n"}, {"fullname": "exdpn.util.util", "modulename": "exdpn.util.util", "type": "module", "doc": "<p>This is a module providing some basic utility functions.</p>\n"}, {"fullname": "exdpn.util.util.import_log", "modulename": "exdpn.util.util", "qualname": "import_log", "type": "function", "doc": "<p>Imports an XES event log from a given path.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the XES event log file.</li>\n<li><strong>verbose (bool, optional):</strong>  If verbose, a progress bar is shown in the console. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>EventLog: The event log object.</p>\n</blockquote>\n\n<h6 id=\"note\">Note</h6>\n\n<blockquote>\n  <p>Please make sure that the event log follows the XES standard.</p>\n</blockquote>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">import_log</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">event_log</span> <span class=\"o\">=</span> <span class=\"n\">import_log</span><span class=\"p\">(</span><span class=\"s1\">&#39;p2p_base.xes&#39;</span><span class=\"p\">)</span>\n</code></pre></div>\n</blockquote>\n", "signature": "(path: str, verbose: bool = False) -> pm4py.objects.log.obj.EventLog", "funcdef": "def"}, {"fullname": "exdpn.util.util.extend_event_log_with_total_elapsed_time", "modulename": "exdpn.util.util", "qualname": "extend_event_log_with_total_elapsed_time", "type": "function", "doc": "<p>Extends each event in an event log with an attribute corresponding to the total time elapsed (in seconds) since the start         of the corresponding case.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>log (EventLog):</strong>  The event log to be extended.</li>\n<li><strong>total_elapsed_time_attribute_name (str, optional):</strong>  The event level attribute name to be used. Default is \"eXdpn::total_elapsed_time\".</li>\n<li><strong>timestamp_attribute_name (str, optional):</strong>  The timestamp attribute name present in the event log. Default is <code>pm4py.util.xes_constants.DEFAULT_NAME_KEY</code> (\"time:timestamp\").</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>KeyError:</strong>  If the attribute with name <code>timestamp_attribute_name</code> is not present in the event log.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">import_log</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">extend_event_log_with_total_elapsed_time</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">event_log</span> <span class=\"o\">=</span> <span class=\"n\">import_log</span><span class=\"p\">(</span><span class=\"s1\">&#39;p2p_base.xes&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">extend_event_log_with_total_elapsed_time</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">)</span>\n</code></pre></div>\n</blockquote>\n", "signature": "(\n    log: pm4py.objects.log.obj.EventLog,\n    total_elapsed_time_attribute_name: str = 'eXdpn::total_elapsed_time',\n    timestamp_attribute_name: str = 'time:timestamp'\n) -> None", "funcdef": "def"}, {"fullname": "exdpn.util.util.extend_event_log_with_preceding_event_delay", "modulename": "exdpn.util.util", "qualname": "extend_event_log_with_preceding_event_delay", "type": "function", "doc": "<p>Extends each event in an event log with an attribute corresponding to the delay (in seconds) between the current event and the preceding event         of the corresponding case. Initial events of each case have a delay of 0 seconds.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>log (EventLog):</strong>  The event log to be extended.</li>\n<li><strong>preceding_event_delay_attribute_name (str, optional):</strong>  The event level attribute name to be used. Default is \"eXdpn::preceding_event_delay\".</li>\n<li><strong>timestamp_attribute_name (str, optional):</strong>  The timestamp attribute name present in the event log. Default is <code>pm4py.util.xes_constants.DEFAULT_NAME_KEY</code> (\"time:timestamp\").</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>KeyError:</strong>  If the attribute with name <code>timestamp_attribute_name</code> is not present in the event log.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">import_log</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">exdpn.util</span> <span class=\"kn\">import</span> <span class=\"n\">extend_event_log_with_preceding_event_delay</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">event_log</span> <span class=\"o\">=</span> <span class=\"n\">import_log</span><span class=\"p\">(</span><span class=\"s1\">&#39;p2p_base.xes&#39;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">extend_event_log_with_preceding_event_delay</span><span class=\"p\">(</span><span class=\"n\">event_log</span><span class=\"p\">)</span>\n</code></pre></div>\n</blockquote>\n", "signature": "(\n    log: pm4py.objects.log.obj.EventLog,\n    preceding_event_delay_attribute_name: str = 'eXdpn::preceding_event_delay',\n    timestamp_attribute_name: str = 'time:timestamp'\n) -> None", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();